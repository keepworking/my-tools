<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>my-tools</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif; margin: 0; }
    header { padding: 20px 16px; border-bottom: 1px solid rgba(127,127,127,.25); }
    h1 { margin: 0 0 6px; font-size: 20px; }
    .meta { display:flex; flex-wrap:wrap; gap:10px; opacity:.8; font-size: 13px; }
    main { padding: 16px; max-width: 980px; margin: 0 auto; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    input[type="search"] { flex: 1 1 320px; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(127,127,127,.35); background: transparent; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(127,127,127,.35); background: transparent; cursor: pointer; }
    button:hover { border-color: rgba(127,127,127,.65); }
    .status { margin: 12px 0; font-size: 13px; opacity:.85; }
    .error { color: #d00; }
    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 12px; margin-top: 12px; }
    .card { border: 1px solid rgba(127,127,127,.25); border-radius: 14px; padding: 12px; }
    .card a { text-decoration: none; }
    .path { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 12px; opacity:.9; word-break: break-all; }
    .name { margin: 6px 0 0; font-weight: 650; }
    .tag { display:inline-block; font-size: 11px; padding: 2px 8px; border-radius: 999px; border: 1px solid rgba(127,127,127,.35); opacity:.85; margin-top: 10px; }
    details { margin-top: 16px; }
    code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    pre { white-space: pre-wrap; word-break: break-word; background: rgba(127,127,127,.08); padding: 12px; border-radius: 12px; border: 1px solid rgba(127,127,127,.2); }
    footer { padding: 16px; opacity: .75; font-size: 12px; border-top: 1px solid rgba(127,127,127,.25); margin-top: 20px; }
  </style>
</head>
<body>
<header>
  <h1>my-tools</h1>
  <div class="meta" id="meta"></div>
</header>

<main>
  <div class="row">
    <input id="q" type="search" placeholder="필터 (예: chart, /demo, utils)" autocomplete="off" />
    <button id="reload" type="button">새로고침</button>
    <button id="copy" type="button">목록 복사</button>
  </div>

  <div class="status" id="status">로딩 중…</div>
  <div class="grid" id="grid"></div>

  <details>
    <summary>동작 방식 / 대체 방법</summary>
    <pre id="help"></pre>
  </details>
</main>

<footer>
  GitHub Pages에서 실행되며, 리포지터리 내 .html 파일을 자동으로 링크합니다.
</footer>

<script>
(() => {
  "use strict";

  // ---- 설정(필요하면 여기만 바꾸면 됩니다) ----
  // URL에서 owner/repo를 자동 추론하지만, 실패하면 아래 값 사용
  const FALLBACK_OWNER = ""; // 예: "your-username"
  const FALLBACK_REPO  = "my-tools";
  const MANIFEST_PATH  = "./tools-manifest.json"; // 선택: API 없이 목록 만들 때 사용

  const EXCLUDE = new Set([
    "index.html",
    "404.html"
  ]);

  const state = {
    owner: null,
    repo: null,
    branch: null,
    basePath: null,
    items: []
  };

  const el = (id) => document.getElementById(id);
  const $meta = el("meta");
  const $status = el("status");
  const $grid = el("grid");
  const $q = el("q");
  const $reload = el("reload");
  const $copy = el("copy");
  const $help = el("help");

  function setStatus(msg, isError = false) {
    $status.textContent = msg;
    $status.className = "status" + (isError ? " error" : "");
  }

  function escapeHtml(s) {
    return s.replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  function parseOwnerRepoFromLocation() {
    // Project Pages: https://{owner}.github.io/{repo}/...
    // User/Org Pages: https://{owner}.github.io/  (repo는 owner.github.io)
    const host = location.hostname;
    const path = location.pathname.replace(/\/+$/, ""); // trim trailing slash
    const segs = path.split("/").filter(Boolean);

    let owner = null, repo = null, basePath = "/";

    if (host.endsWith(".github.io")) {
      owner = host.split(".github.io")[0];
      if (segs.length >= 1) {
        repo = segs[0];
        basePath = "/" + repo + "/";
      } else {
        // user pages root
        repo = owner + ".github.io";
        basePath = "/";
      }
    } else {
      // custom domain: cannot reliably infer. use fallback.
      owner = FALLBACK_OWNER || null;
      repo = FALLBACK_REPO || null;
      // basePath should be root for custom domain
      basePath = "/";
    }

    // allow explicit override via query ?owner=...&repo=...
    const params = new URLSearchParams(location.search);
    if (params.get("owner")) owner = params.get("owner");
    if (params.get("repo")) repo = params.get("repo");
    if (params.get("base")) basePath = params.get("base").replace(/\/?$/, "/").replace(/^([^/])/, "/$1"); // normalize

    if (!owner) owner = FALLBACK_OWNER || null;
    if (!repo) repo = FALLBACK_REPO || null;

    return { owner, repo, basePath };
  }

  async function fetchJson(url, opts = {}) {
    const res = await fetch(url, {
      headers: { "Accept": "application/vnd.github+json" },
      ...opts
    });
    if (!res.ok) {
      const text = await res.text().catch(() => "");
      const msg = text ? `${res.status} ${res.statusText}: ${text.slice(0, 200)}` : `${res.status} ${res.statusText}`;
      throw new Error(msg);
    }
    return res.json();
  }

  async function tryLoadManifest() {
    // Manifest format (예시):
    // { "html": ["tools/a.html", "demo/b.html"] }
    // 또는 ["tools/a.html", "demo/b.html"]
    const res = await fetch(MANIFEST_PATH, { cache: "no-store" });
    if (!res.ok) return null;

    const data = await res.json();
    if (Array.isArray(data)) return data;
    if (data && Array.isArray(data.html)) return data.html;
    return null;
  }

  async function getDefaultBranch(owner, repo) {
    const repoInfo = await fetchJson(`https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}`);
    return repoInfo.default_branch || "main";
  }

  async function listHtmlViaGitTree(owner, repo, branch) {
    // git trees API (recursive=1)
    // NOTE: 큰 리포지터리면 트리 크기 제한에 걸릴 수 있습니다.
    const tree = await fetchJson(`https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/git/trees/${encodeURIComponent(branch)}?recursive=1`);
    const nodes = tree.tree || [];
    const htmlPaths = nodes
      .filter(n => n.type === "blob" && typeof n.path === "string" && n.path.toLowerCase().endsWith(".html"))
      .map(n => n.path)
      .filter(p => !EXCLUDE.has(p.split("/").pop().toLowerCase()));

    return htmlPaths;
  }

  function normalizeAndSort(paths) {
    // remove duplicates and sort
    const uniq = Array.from(new Set(paths.map(p => p.replace(/^\.?\//, ""))));
    uniq.sort((a, b) => a.localeCompare(b));
    return uniq;
  }

  function toLink(path) {
    // GitHub Pages 경로 기준으로 링크 생성
    // basePath already ends with /
    return state.basePath + path.split("/").map(encodeURIComponent).join("/");
  }

  function renderMeta() {
    const repoUrl = `https://github.com/${state.owner}/${state.repo}`;
    $meta.innerHTML = [
      `<span><b>owner</b>: ${escapeHtml(state.owner)}</span>`,
      `<span><b>repo</b>: <a href="${repoUrl}" target="_blank" rel="noreferrer">${escapeHtml(state.repo)}</a></span>`,
      state.branch ? `<span><b>branch</b>: ${escapeHtml(state.branch)}</span>` : "",
      `<span><b>base</b>: ${escapeHtml(state.basePath)}</span>`
    ].filter(Boolean).join(" · ");
  }

  function renderGrid(filterText = "") {
    const f = filterText.trim().toLowerCase();

    const items = state.items.filter(p => {
      if (!f) return true;
      return p.toLowerCase().includes(f);
    });

    $grid.innerHTML = items.map(p => {
      const file = p.split("/").pop();
      const folder = p.includes("/") ? p.slice(0, p.lastIndexOf("/")) : "(root)";
      const href = toLink(p);
      return `
        <div class="card">
          <a href="${href}">
            <div class="path">${escapeHtml(p)}</div>
            <div class="name">${escapeHtml(file)}</div>
          </a>
          <div class="tag">${escapeHtml(folder)}</div>
        </div>
      `;
    }).join("");

    setStatus(items.length ? `총 ${items.length}개` : "결과 없음");
  }

  function renderHelp() {
    const txt = [
`1) 기본 동작
- GitHub Pages에서 현재 URL을 보고 owner/repo를 추론합니다.
- 우선 ./tools-manifest.json 이 있으면 그걸 사용합니다(추천).
- 없으면 GitHub API로 리포지터리 트리를 재귀 조회해서 .html 파일을 모읍니다.

2) 매니페스트 방식(추천, API 제한 회피)
- 리포지터리에 tools-manifest.json 파일을 추가하면 API 없이 바로 목록이 뜹니다.
- 형식 예:
  ["a.html","demo/b.html"]
  또는
  { "html": ["a.html","demo/b.html"] }

3) GitHub API 방식
- 사용 API:
  - GET /repos/{owner}/{repo}  (default_branch 확인)
  - GET /repos/{owner}/{repo}/git/trees/{branch}?recursive=1  (.html 경로 추출)
- 토큰 없이 호출하면 rate limit이 걸릴 수 있습니다(특히 새로고침 연타).

4) 강제 지정(추론 실패/커스텀 도메인 대응)
- 쿼리스트링으로 지정 가능:
  ?owner=YOURNAME&repo=my-tools
  (필요하면) ?base=/my-tools/
`
    ].join("\n");
    $help.textContent = txt;
  }

  async function load() {
    try {
      setStatus("로딩 중…");
      const { owner, repo, basePath } = parseOwnerRepoFromLocation();
      state.owner = owner;
      state.repo = repo;
      state.basePath = basePath.endsWith("/") ? basePath : (basePath + "/");
      renderHelp();

      if (!state.owner || !state.repo) {
        throw new Error("owner/repo를 결정할 수 없습니다. FALLBACK_OWNER 값을 넣거나, ?owner=...&repo=... 로 지정하세요.");
      }

      // 1) manifest first
      const manifestList = await tryLoadManifest();
      if (manifestList) {
        state.items = normalizeAndSort(manifestList.filter(p => (p || "").toLowerCase().endsWith(".html")));
        state.branch = "(manifest)";
        renderMeta();
        renderGrid($q.value);
        return;
      }

      // 2) GitHub API fallback
      state.branch = await getDefaultBranch(state.owner, state.repo);
      renderMeta();
      const htmlPaths = await listHtmlViaGitTree(state.owner, state.repo, state.branch);
      state.items = normalizeAndSort(htmlPaths);

      renderGrid($q.value);
    } catch (e) {
      console.error(e);
      renderMeta();
      setStatus(
        `실패: ${String(e && e.message ? e.message : e)}`,
        true
      );
      $grid.innerHTML = "";
    }
  }

  // events
  $q.addEventListener("input", () => renderGrid($q.value));
  $reload.addEventListener("click", () => load());
  $copy.addEventListener("click", async () => {
    const text = state.items.map(p => `${toLink(p)}\t${p}`).join("\n");
    try {
      await navigator.clipboard.writeText(text);
      setStatus("복사 완료");
    } catch {
      // fallback
      const ta = document.createElement("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      setStatus("복사 완료(대체 방식)");
    }
  });

  load();
})();
</script>
</body>
</html>

